<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Coding Assignment 4: Coding Assignment 4</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Coding Assignment 4
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Coding Assignment 4 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#sec">Introduction</a></li>
<li class="level1"><a href="#sec2">Solid</a><ul><li class="level2"><a href="#subsec1">run</a></li>
<li class="level2"><a href="#subsec2">solve_load_step_NR()</a></li>
<li class="level2"><a href="#subsec3">make_constraints()</a></li>
<li class="level2"><a href="#sebsec4">Assembly</a></li>
<li class="level2"><a href="#subsec5">Solving the linear system</a></li>
<li class="level2"><a href="#sebsec6">MISC</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="sec"></a>
Introduction</h1>
<p>In this coding assignment we will take a closer look at the Newton-Raphson algorithm and its implementation within our code. Again look out for the following</p>
<p><em>BEGIN</em> - INSERT YOUR CODE HERE</p>
<p><em>END</em> - INSERT YOUR CODE HERE</p>
<p>which indicates where you should complete the code.</p>
<p>As always make use of the deal.II online library <a href="https://dealii.org/9.1.1/doxygen/deal.II/">deal.II</a></p>
<p>Also, recall to first load the environment variable in a shell via</p>
<p><em>spack</em> load dealii</p>
<p>and then execute cmake</p>
<p><em>cmake</em> .</p>
<p>in the current folder to generate the Makefile. You can then use "make debug" or "make release" to switch between the two configurations and finally "make run" to execute the program.</p>
<h1><a class="anchor" id="sec2"></a>
Solid</h1>
<p>This is the main solver class which solves the balance of linear momentum for a either two- or three dimensional slice (cube) with a cylindrical hole (see HyperCubeWithRefinedHole from a prior coding assignment; in the two dimensional case -&gt; plane strain). The member functions that need to be worked on are <a class="el" href="classSolid.html#a264a27250d20aea587d738de48751192">Solid&lt;dim&gt;::make_constraints</a>, <a class="el" href="classSolid.html#a6162f2ab87e3061ab2a44280b472af0b">Solid&lt;dim&gt;::assemble_system</a> and <a class="el" href="classSolid.html#a2ca1326fa3a3c4f6395ef22b80923f45">Solid&lt;dim&gt;::solve_load_step_NR</a>. Before we start lets have a quick look at function <a class="el" href="classSolid.html#a012c69961c6f1c4d351a243eaa910cbd">Solid&lt;dim&gt;::run</a> which is the only public function of our solver class.</p>
<h2><a class="anchor" id="subsec1"></a>
run</h2>
<p>The function <a class="el" href="classSolid.html#a012c69961c6f1c4d351a243eaa910cbd">Solid::run</a> calls the private member functions needed to run the program. First a grid is generated. As discussed in another prior exercise the <a class="el" href="classSolid.html#a967492d94e02b5d52bd1f8c8e3054820">Solid&lt;dim&gt;::system_setup</a> sets up a sparsity pattern and takes care of the sparse matrix and global vectors, i.e. the residual, the solution and the solution update. Thereafter the program loops over all load steps, solves in every step the nonlinear problem using a Newton-Raphson Algorithm, adds the NR-increment to the global solution increment and writes out the displacements (<a class="el" href="classSolid.html#ae96bd2d3c54d563be2807dad0a69eae6">Solid&lt;dim&gt;::output_results</a>). The functions <a class="el" href="classSolid.html#a264a27250d20aea587d738de48751192">Solid::make_constraints</a> and <a class="el" href="classSolid.html#a6162f2ab87e3061ab2a44280b472af0b">Solid::assemble_system</a> are called from withing the <a class="el" href="classSolid.html#a2ca1326fa3a3c4f6395ef22b80923f45">Solid::solve_load_step_NR</a> function.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="classSolid.html#a012c69961c6f1c4d351a243eaa910cbd">Solid&lt;dim&gt;::run</a>()</div><div class="line">{</div><div class="line">    make_grid();</div><div class="line">    system_setup();</div><div class="line">    <span class="comment">//output initial values (here: =0)</span></div><div class="line">    output_results();</div><div class="line">    <span class="comment">//Loop over the number of load_steps (see class declaration)</span></div><div class="line">    <span class="keywordflow">for</span> (current_load_step=1; current_load_step &lt;= load_steps; current_load_step++)</div><div class="line">    {</div><div class="line">            <span class="comment">//Always reset the increment vector - not to be mistaken with</span></div><div class="line">            <span class="comment">// the newton update!!!</span></div><div class="line">            solution_delta = 0.0;</div><div class="line">            <span class="comment">//Compute for the current load step the incremental solution using</span></div><div class="line">            <span class="comment">//Newton-Rapshon</span></div><div class="line">            solve_load_step_NR(solution_delta);</div><div class="line">            <span class="comment">//add the converged delta to the solution - not to be mistaken with</span></div><div class="line">            <span class="comment">//the newton update!!! </span></div><div class="line">            solution_n += solution_delta;</div><div class="line">            output_results();</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>The starting point of this exercise is the function <a class="el" href="classSolid.html#a2ca1326fa3a3c4f6395ef22b80923f45">Solid&lt;dim&gt;::solve_load_step_NR</a>.</p>
<h2><a class="anchor" id="subsec2"></a>
solve_load_step_NR()</h2>
<p>This is the function that executes the Newton-Raphson algorithm. We will make use of a local vector that is used for the newton-increments:</p>
<div class="fragment"><div class="line"> <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="classSolid.html#a2ca1326fa3a3c4f6395ef22b80923f45">Solid&lt;dim&gt;::solve_load_step_NR</a>(Vector&lt;double&gt; &amp;solution_delta)</div><div class="line">{</div><div class="line">    <span class="comment">//A vector used for all the newton increments</span></div><div class="line">    Vector&lt;double&gt; newton_update(dof_handler_ref.n_dofs());</div></div><!-- fragment --><p>Afterwards we reset the instances of the struct <a class="el" href="structSolid_1_1Errors.html">Solid::Errors</a> that are used for the convergence criterion. In essence we will compute the l2-norm of the residual (excluding the constraint dof's using <a class="el" href="classSolid.html#a2d8ba8b46344071ab24526312cc75757">Solid&lt;dim&gt;::get_error_residual</a>) in every newton-step and store it into error_residual. Since we intend to use a normalised value we store the value in the very first newton-iteration into error_residual_0 and use it to compute the normalised value error_residual_norm.</p>
<div class="fragment"><div class="line"><span class="comment">//Reset the structs used for convergence criteria</span></div><div class="line">error_residual.reset();</div><div class="line">error_residual_0.reset();</div><div class="line">error_residual_norm.reset();</div><div class="line"><span class="comment">//Print info to the screen</span></div><div class="line">print_conv_header();</div></div><!-- fragment --><p>Now, we enter the actual Newton-Rapshon algorithm where we loop over a maximum number of newton_iteration and leave the loop as soon as convergence is achieved. The first tasks are to reset the tangent matrix and the rhs vector since we will fill these quantities using <a class="el" href="classSolid.html#a6162f2ab87e3061ab2a44280b472af0b">Solid&lt;dim&gt;::assemble_system</a>. Afterwards, we need to call the function <a class="el" href="classSolid.html#a264a27250d20aea587d738de48751192">Solid&lt;dim&gt;::make_constraints</a> BEFORE we call the <a class="el" href="classSolid.html#a6162f2ab87e3061ab2a44280b472af0b">Solid&lt;dim&gt;::assemble_system</a> function due to the way we consider both, hanging nodes and Dirichlet type constraints "on-the-fly". </p><div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> newton_iteration = 0;</div><div class="line"><span class="keywordflow">for</span> (; newton_iteration &lt;= max_number_newton_iterations;</div><div class="line">        ++newton_iteration)</div><div class="line">{</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; std::setw(2) &lt;&lt; newton_iteration &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; std::flush;</div><div class="line"></div><div class="line">    <span class="comment">//BEGIN - INSERT YOUR CODE HERE</span></div><div class="line">    <span class="comment">//RESET THE TANGENT MATRIX, THE RHS</span></div><div class="line">    <span class="comment">//CALL THE FUNCTIONS make_constraints (WITH THE CORRECT PARAMETER)</span></div><div class="line">    <span class="comment">//AND ASSEMBLE_SYSTEM</span></div><div class="line"></div><div class="line">    </div><div class="line">    <span class="comment">//END - INSERT YOUR CODE HERE</span></div></div><!-- fragment --><p>The next step is to check wether or not convergence is achieved and if so, leave the for loop. If not, solve the linear system and add the newton-increment to the load-step increment. The last step still needs to be implemented. </p><div class="fragment"><div class="line">    get_error_residual(error_residual);</div><div class="line">    <span class="keywordflow">if</span> (newton_iteration == 0)</div><div class="line">    {</div><div class="line">        error_residual_0 = error_residual;</div><div class="line">    }</div><div class="line">    error_residual_norm = error_residual;</div><div class="line">    error_residual_norm.normalise(error_residual_0);</div><div class="line"></div><div class="line">    <span class="comment">//Problem has to be solved at least once</span></div><div class="line">    <span class="keywordflow">if</span> (newton_iteration &gt; 0 &amp;&amp; error_residual_norm.u &lt;= error_tolerance_residual)</div><div class="line">    {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot; CONVERGED! &quot;</span> &lt;&lt; std::endl;</div><div class="line">        <span class="comment">//Print info to the screen</span></div><div class="line">        print_conv_footer();</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">    }</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="keyword">const</span> std::pair&lt;unsigned int, double&gt;</div><div class="line">    lin_solver_output = solve_linear_system(newton_update);</div><div class="line">    </div><div class="line">    <span class="comment">//BEGIN - INSERT YOUR CODE HERE</span></div><div class="line">    <span class="comment">//ADD THE NEWTION INCREMENT TO THE LOAD STEP DELTA solution_delta</span></div><div class="line"></div><div class="line">    <span class="comment">//END - INSERT YOUR CODE HERE</span></div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="comment">//Print info to the screen</span></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot; | &quot;</span> &lt;&lt; std::fixed &lt;&lt; std::setprecision(3) &lt;&lt; std::setw(7)</div><div class="line">                &lt;&lt; std::scientific &lt;&lt; lin_solver_output.first &lt;&lt; <span class="stringliteral">&quot;  &quot;</span></div><div class="line">                &lt;&lt; lin_solver_output.second &lt;&lt; <span class="stringliteral">&quot;  &quot;</span> &lt;&lt; error_residual_norm.u </div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;  &quot;</span> &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p>Eventually, before we leave the function we check if the number of max iterations has not been exceeted and if throw an error.</p>
<div class="fragment"><div class="line">      AssertThrow (newton_iteration &lt; max_number_newton_iterations,</div><div class="line">               ExcMessage(<span class="stringliteral">&quot;No convergence in nonlinear solver!&quot;</span>));</div><div class="line"></div><div class="line">}</div></div><!-- fragment --><p>Within the previous function we called <a class="el" href="classSolid.html#a264a27250d20aea587d738de48751192">Solid&lt;dim&gt;::make_constraints</a> and <a class="el" href="classSolid.html#a6162f2ab87e3061ab2a44280b472af0b">Solid&lt;dim&gt;::assemble_system</a> which is yet not completed.</p>
<h2><a class="anchor" id="subsec3"></a>
make_constraints()</h2>
<p>As discussed in the exercise we need to make sure that constraints are correctly imposed. The first task here is to read through the code snipped below and think of an appropiate way to possibly leave the function earlier, based on a certain condition.</p>
<div class="fragment"><div class="line"> <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="classSolid.html#a264a27250d20aea587d738de48751192">Solid&lt;dim&gt;::make_constraints</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> &amp;it_nr)</div><div class="line">{</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot; CST &quot;</span> &lt;&lt; std::flush;</div><div class="line">    <span class="comment">//Check the current number of newton iterations and decide based on </span></div><div class="line">    <span class="comment">// the discussion in the exercise after how many iterations you could </span></div><div class="line">    <span class="comment">// leave this function</span></div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="comment">//CHECK THE CURRENT NUMBER OF NEWTON ITERATION AND DECIDE BASED</span></div><div class="line">    <span class="comment">// ON THE DISCUSSION IN THE EXERCISE AFTER HOW MANY ITERATIONS YOU COULD</span></div><div class="line">    <span class="comment">// LEAVE THIS FUNCTION</span></div><div class="line">    <span class="comment">//BEGIN - INSERT YOUR CODE HERE</span></div><div class="line"></div><div class="line">    <span class="comment">//END - INSERT YOUR CODE HERE</span></div><div class="line">    </div><div class="line">    <span class="comment">//Clear and write hanging node and Dirichlet constraints into</span></div><div class="line">    <span class="comment">// the AffineConstraints constraints</span></div><div class="line">    constraints.clear();</div><div class="line">    DoFTools::make_hanging_node_constraints (dof_handler_ref,constraints);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span> apply_dirichlet_bc = (it_nr == 0);</div><div class="line">    <span class="keyword">const</span> FEValuesExtractors::Vector displacement(0);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> boundary_id = id_Dirichlet_boundary;</div><div class="line"></div><div class="line">    <span class="comment">//if conditional to check which function should be used for the Dirichlet constraints</span></div><div class="line">    <span class="keywordflow">if</span> (apply_dirichlet_bc == <span class="keyword">true</span>)</div><div class="line">    {</div><div class="line">        VectorTools::interpolate_boundary_values(dof_handler_ref,</div><div class="line">                                                boundary_id,</div><div class="line">                                                ZeroFunction&lt;dim&gt;(dim),</div><div class="line">                                                constraints,</div><div class="line">                                                fe.component_mask(displacement));</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        VectorTools::interpolate_boundary_values(dof_handler_ref,</div><div class="line">                                                boundary_id,</div><div class="line">                                                ZeroFunction&lt;dim&gt;(dim),</div><div class="line">                                                constraints,</div><div class="line">                                                fe.component_mask(displacement));   </div><div class="line">    }</div><div class="line">    constraints.close();</div><div class="line">}</div></div><!-- fragment --><p>Recall that a possible alternative would be to use ConstantFunction() if apply_dirichlet_bc == true for inhomogeneous Dirichlet constraints. This ensures that only in the very first newton step the desired value is prescribed and remains unchanged throughout the NR-algorithm. Read the documentation of VectorTools::interpolate_boundary_values() and search for the version of the function that we use in this example. It is further helpful to read to documentation on ComponentMask() which is used here and the FEValuesExtractors will also be used later in that exercise.</p>
<h2><a class="anchor" id="sebsec4"></a>
Assembly</h2>
<p>Considering the assembly routine we first create an instance of the class NeoHookeanMaterial which has been the topic of a prior coding assignment, by passing the two Lame paramters \( \mu \) and \( \lambda \). </p><div class="fragment"><div class="line"> <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="classSolid.html#a6162f2ab87e3061ab2a44280b472af0b">Solid&lt;dim&gt;::assemble_system</a>()</div><div class="line">{</div><div class="line">    </div><div class="line">    </div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot; Assemble System &quot;</span> &lt;&lt; std::flush;</div><div class="line"></div><div class="line">    </div><div class="line">    NeoHookeanMaterial&lt;dim&gt; material(this-&gt;mu, this-&gt;lambda);</div></div><!-- fragment --><p>Thereafter we create two instances of FEValues&lt;dim&gt; and FEFaceValues&lt;dim&gt; as discussed in the exercise. They group together the information about FiniteElement, quadrature and a mapping from a real to the reference cell and allow to query quantities, like the shape function value at the quadrature point. There is a variety of different quantities available. To compute them the instances of the respective classes have to be reinitialized with the information of the current cell. To prevent the repeated computation of possibly unnecessary data, we tell the class via UpdateFlag, e.g. <em>update_values</em> | <em>update_gradients</em> , etc. to only compute these values. Further parameters that are passed are the FiniteElement, in our case <em>fe</em> and the quadrature formula, i.e. <em>qf_cell</em>.</p>
<div class="fragment"><div class="line"><span class="comment">//FEValues and FaceValues to compute quantities on quadrature points for our finite</span></div><div class="line"><span class="comment">//element space including mapping from the real cell</span></div><div class="line">FEValues&lt;dim&gt; fe_values_ref (fe,<span class="comment">//The used FiniteElement</span></div><div class="line">                            qf_cell,<span class="comment">//The quadrature rule for the cell</span></div><div class="line">                            update_values| <span class="comment">//UpdateFlag for shape function values</span></div><div class="line">                            update_gradients| <span class="comment">//shape function gradients</span></div><div class="line">                            update_JxW_values); <span class="comment">//transformed quadrature weights multiplied with Jacobian of transformation </span></div><div class="line">FEFaceValues&lt;dim&gt; fe_face_values_ref (fe,</div><div class="line">                                    qf_face, <span class="comment">//The quadrature for face quadrature points</span></div><div class="line">                                    update_values|</div><div class="line">                                    update_normal_vectors| <span class="comment">//compute normal vector for face</span></div><div class="line">                                    update_JxW_values);</div></div><!-- fragment --><p> Afterwards we create containers to store the contribution of each cell to the global problem, i.e. a FullMatrix&lt;double&gt; and a Vector&lt;double&gt;, both using the number of dof's per cell (<em>dofs_per_cell</em>) which has been computed in the constructor of our solver class. Furthermore we create a std::vector of the type <em>types::global_dof_index</em> in which the indicies of the local dof's in the global system are stored. </p><div class="fragment"><div class="line"><span class="comment">//Quantities to store the local rhs and matrix contribution</span></div><div class="line">FullMatrix&lt;double&gt; cell_matrix(dofs_per_cell,dofs_per_cell);</div><div class="line">Vector&lt;double&gt; cell_rhs (dofs_per_cell);</div><div class="line"><span class="comment">//Vector with the indicies (global) of the local dofs   </span></div><div class="line">std::vector&lt;types::global_dof_index&gt; local_dof_indices (dofs_per_cell);</div></div><!-- fragment --><p>The next step is to compute the total solution, which includes the starting value of the current load step and the current solution_delta as rendered in the Newton-Raphson algorithm and store it in the Vector <em>current_solution</em>. Now we can start to loop over all active cells, reseting the local matrix and rhs for every cell and reinitializing the FEValues&lt;dim&gt; instance with the current active cell <em>cell</em>.</p>
<div class="fragment"><div class="line"><span class="comment">//Compute the current, total solution, i.e. starting value of</span></div><div class="line"><span class="comment">//current load step and current solution_delta</span></div><div class="line">Vector&lt;double&gt; current_solution = get_total_solution(this-&gt;solution_delta);</div><div class="line"><span class="comment">//Iterators to loop over all active cells</span></div><div class="line"><span class="keyword">typename</span> DoFHandler&lt;dim&gt;::active_cell_iterator cell = dof_handler_ref.begin_active(),</div><div class="line">                                            endc = dof_handler_ref.end();</div><div class="line">                                            </div><div class="line"><span class="keywordflow">for</span>(;cell!=endc;++cell)</div><div class="line">{</div><div class="line">    <span class="comment">//Reset the local rhs and matrix for every cell</span></div><div class="line">    cell_matrix=0.0;</div><div class="line">    cell_rhs=0.0;</div><div class="line">    <span class="comment">//Reinit the FEValues instance for the current cell, i.e.</span></div><div class="line">    <span class="comment">//compute the values for the current cell</span></div><div class="line">    fe_values_ref.reinit(cell);</div></div><!-- fragment --><p>Next a container is created that allows to store 2nd order tensors (in total <em>n_q_points</em> of it). By calling the function FEValues&lt;dim&gt;::get_function_gradients() with the current solution, the FEValuesExtractors::Vector and the container the quantities \( \nabla_X \mathbf{N}_i\) are computed for all quadrature points. In addition we fill the container <em>local_dof_indices</em>.</p>
<div class="fragment"><div class="line"><span class="comment">//Vector to store the gradients of the solution at </span></div><div class="line"><span class="comment">//n_q_points quadrature points</span></div><div class="line">std::vector&lt;Tensor&lt;2,dim&gt; &gt; solution_grads_u(n_q_points);</div><div class="line"><span class="comment">//Fill the previous vector using get_function_gradients</span></div><div class="line">fe_values_ref[u_fe].get_function_gradients(current_solution,solution_grads_u);</div><div class="line"><span class="comment">//Write the global indicies of the local dofs of the current cell</span></div><div class="line">cell-&gt;get_dof_indices(local_dof_indices);</div></div><!-- fragment --><p>In the sequent we will loop over all quadrature points, the test functions and the ansatz functions, which is in our case \( k,i,j \).</p>
<p>This includes the contributions to the residual based on the formulation discussed in the exercise:</p>
<p>\( \mathbf{r}(i) -= (\nabla_x \mathbf{N}^{\text{sym}}_i(qp) : \boldsymbol{\tau}(qp) ) \cdot \text{JxW}(qp) \)</p>
<p>and</p>
<p>\( \mathbf{r}(i) += (\mathbf{N}_i(f\_qp) \cdot \mathbf{T}(f\_qp) ) \cdot \text{JxW}(f\_qp) \)</p>
<p>with \( \mathbf{T} = current\_load * \mathbf{N}(f\_qp) (\text{ , i.e. the normal vector times the load factor}) \). Be aware that we already changed the signs for the residual part since we use Newton-Raphson and would need \( \mathbf{K} \Delta \mathbf{u} = - \mathbf{R} \).</p>
<p>The contribution to the tangent matrix consisting of a geometrical contribution</p>
<p>\( \mathbf{K}(i,j) += (\nabla_x \mathbf{N}^T_i(qp) \cdot \nabla_x \mathbf{N}_j(qp) )^{\text{sym}} : \boldsymbol{\tau}(qp) \cdot \text{JxW}(qp)\)</p>
<p>and a material contribution</p>
<p>\( \mathbf{K}(i,j) += (\nabla_x \mathbf{N}^{\text{sym}}_i(qp) : (\boldsymbol{c}J) : \nabla_x \mathbf{N}^{\text{sym}}_j(qp) ) \cdot \text{JxW}(qp)\).</p>
<p>REMARK: the function NeoHookeanMaterial&lt;dim&gt;::get_Tangent_spt() returns the tangent multiplied with \( J \) so there is no need to multiply the value again with the Jacobian. Starting point is the loop over all quadrature points. This is also the first point where you have to complete the code by computing the required quantities.</p>
<div class="fragment"><div class="line"><span class="comment">//Loop over all quadrature points of the cell</span></div><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0; k&lt;n_q_points;++k)</div><div class="line">{</div><div class="line">    <span class="comment">//BEGIN - INSERT YOUR CODE HERE</span></div><div class="line">    <span class="comment">//Compute here the following</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">//- deformation gradient using the information in &quot;solution_grads_u[k]&quot; and &quot;StandardTensors::I&lt;dim&gt;()&quot;</span></div><div class="line">    <span class="comment">//- use the deformation gradient to compute</span></div><div class="line">    <span class="comment">//- - Kirchhoffstress</span></div><div class="line">    <span class="comment">//- - Tangent</span></div><div class="line">    <span class="comment">//- Compute the inverse of the Deformation gradient</span></div><div class="line"></div><div class="line">    <span class="comment">//END - INSERT YOUR CODE HERE</span></div><div class="line">    </div><div class="line">    <span class="comment">//The quadrature weight for the current quadrature point</span></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> JxW = fe_values_ref.JxW(k);</div></div><!-- fragment --><p>Use the instance of the NeoHookeanMaterial class to compute the Kirchhoff stress and the spatial tangent. Afterwards we have a loop over all <em>dofs_per_cell</em> to assemble the local contribution to the residual:</p>
<div class="fragment"><div class="line"><span class="comment">//Loop over all dof&#39;s of the cell</span></div><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">{</div><div class="line">    <span class="comment">//Assemble system_rhs contribution</span></div><div class="line">    <span class="comment">//BEGIN - INSERT YOUR CODE HERE</span></div><div class="line">    <span class="comment">//Compute here the following</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">//- the symmetric (SymmetricTensor&lt;2,dim&gt;) gradient with respect to the spatial configuration</span></div><div class="line">    <span class="comment">//  for the test function as discussed in the exercise (i) -&gt; use fe_values_ref[u_fe] and F_inv</span></div><div class="line">    <span class="comment">//- write into cell_rhs(i)-= the contribution for the current test function at the current quadrature point</span></div><div class="line">    <span class="comment">//  !! &quot;-=&quot; due to Newton-Raphson algorithm K\du = -r</span></div><div class="line"></div><div class="line">    <span class="comment">//END - INSERT YOUR CODE HERE</span></div></div><!-- fragment --><p>Be aware about the necessary transformations and remember from the first coding assignment how to compute a double contraction of symmetric tensors. Further, it has been shown how to access data from FEValues&lt;dim&gt;, which is required to compute gradient of the <em>i-th</em> shape function at the <em>k-th</em> quadrature point. The next step is to compute the local tangent contributions as discussed in the exercise. Again, use the instance of FEValues&lt;dim&gt; to compute the necessary quantities.</p>
<div class="fragment"><div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">        {</div><div class="line">            <span class="comment">//Assemble tangent contribution</span></div><div class="line">            <span class="comment">//BEGIN - INSERT YOUR CODE HERE</span></div><div class="line">            <span class="comment">//Compute here the following</span></div><div class="line">            <span class="comment">//</span></div><div class="line">            <span class="comment">//- the symmetric (SymmetricTensor&lt;2,dim&gt;) gradient with respect to the spatial configuration</span></div><div class="line">            <span class="comment">//  for the ansatz function as discussed in the exercise (j) -&gt; use fe_values_ref[u_fe] and F_inv</span></div><div class="line">            <span class="comment">//- write into cell_matrix(i,j) the material and geometrical contributions for the tangent</span></div><div class="line"></div><div class="line">            <span class="comment">//END - INSERT YOUR CODE HERE                   </span></div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>The last part is to compute the Neumann boundary conditions (this is already implemented for you). Therefore we have to loop over all faces of the current cell and check (i) if the face is indeed at the boundary and (ii) if it has the boundary <em>id_Neumann_boundary</em>. If we found such a face, we reinitialize our instance of FEFaceValues&lt;dim&gt; for the current cell and the current face. Following that a loop over all dof's is necessary similar to the prior contribution to the global residual. Be aware again of the change of the sign.</p>
<div class="fragment"><div class="line"><span class="comment">//Check for Neumann boundary condition</span></div><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face=0; face &lt; GeometryInfo&lt;dim&gt;::faces_per_cell; ++face)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span>(cell-&gt;face(face)-&gt;at_boundary() &amp;&amp; cell-&gt;face(face)-&gt;boundary_id() == id_Neumann_boundary )</div><div class="line">    {</div><div class="line">        fe_face_values_ref.reinit(cell, face);</div><div class="line">        </div><div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> f_q_point = 0; f_q_point &lt; n_q_points_f; ++f_q_point)</div><div class="line">        {</div><div class="line">            <span class="keywordtype">double</span> step_fraction = double(current_load_step)/double(load_steps);</div><div class="line">            <span class="keywordtype">double</span> current_load = load_magnitude * step_fraction;</div><div class="line">            <span class="comment">//Compute the following</span></div><div class="line">            <span class="comment">//</span></div><div class="line">            <span class="comment">//- The normal vector of the current face at the current quadrature point (fe_face_values_ref)</span></div><div class="line">            <span class="comment">//- The normal vector scaled with &quot;current_load&quot;</span></div><div class="line">            <span class="keyword">const</span> Tensor&lt;1,dim&gt; NormalVector = fe_face_values_ref.normal_vector(f_q_point);</div><div class="line">            <span class="keyword">const</span> Tensor&lt;1,dim&gt; Traction = current_load  * NormalVector;</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i&lt; dofs_per_cell; ++i)</div><div class="line">            {</div><div class="line">                <span class="comment">//Compute</span></div><div class="line">                <span class="comment">//</span></div><div class="line">                <span class="comment">//- the test function at the face quadrature point for the i-th test function</span></div><div class="line">                <span class="comment">//- write into cell_rhs(i)+= the contribution due to the Neumann boundary condition (-=(-))-&gt;+=</span></div><div class="line"><span class="comment"></span>                <span class="keyword">const</span> Tensor&lt;1,dim&gt; shape_function = fe_face_values_ref[u_fe].value(i,f_q_point);</div><div class="line">                cell_rhs(i)+= (shape_function * Traction) * fe_face_values_ref.JxW(f_q_point);</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Lastly the local contributions are written into the global residual and tangent matrix using the AffineConstraints. This also takes care about hanging nodes and Dirichlet constraints as discussed in the exercise.</p>
<div class="fragment"><div class="line">        <span class="comment">//copy local to global</span></div><div class="line">        constraints.distribute_local_to_global(cell_matrix,cell_rhs,</div><div class="line">                                local_dof_indices,</div><div class="line">                                tangent_matrix,system_rhs,<span class="keyword">false</span>);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="subsec5"></a>
Solving the linear system</h2>
<p>To solve the arising linear system we use the CG solver (solver_type = "CG"). Yet the CG algorithm and preconditioning is beyond the scope of this assignment. </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">std::pair&lt;unsigned int, double&gt;</div><div class="line"><a class="code" href="classSolid.html#acbb0bc059e6ed8c6a455c6bcd11aeece">Solid&lt;dim&gt;::solve_linear_system</a>(Vector&lt;double&gt; &amp;newton_update)</div><div class="line">{</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> lin_it = 0;</div><div class="line">    <span class="keywordtype">double</span> lin_res = 0.0;</div><div class="line">    std::string solver_type = <span class="stringliteral">&quot;CG&quot;</span>;</div><div class="line">    <span class="comment">//reset the vector newton update</span></div><div class="line">    newton_update=0;</div><div class="line">    </div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot; SLV &quot;</span> &lt;&lt; std::flush;</div><div class="line">    <span class="keywordflow">if</span> (solver_type == <span class="stringliteral">&quot;CG&quot;</span>)</div><div class="line">    {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">int</span> solver_its = tangent_matrix.m()</div><div class="line">                                  multiplier_max_iterations_linear_solver;</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> tol_sol = 1e-9</div><div class="line">                                  system_rhs.l2_norm();</div><div class="line"></div><div class="line">        SolverControl solver_control(solver_its, tol_sol);</div><div class="line"></div><div class="line">        GrowingVectorMemory&lt;Vector&lt;double&gt; &gt; GVM;</div><div class="line">        SolverCG&lt;Vector&lt;double&gt; &gt; solver_CG(solver_control, GVM);</div><div class="line">        PreconditionSSOR&lt;&gt; preconditioner;</div><div class="line">        preconditioner.initialize(tangent_matrix, 1.2);</div><div class="line">        solver_CG.solve(tangent_matrix,</div><div class="line">                        newton_update,</div><div class="line">                        system_rhs,</div><div class="line">                        preconditioner);</div><div class="line">        lin_it = solver_control.last_step();</div><div class="line">        lin_res = solver_control.last_value();</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        <span class="comment">//throug an error message that the chosen solver type is not implented</span></div><div class="line">        Assert (<span class="keyword">false</span>, ExcMessage(<span class="stringliteral">&quot;Linear solver type not implemented&quot;</span>));</div><div class="line">    }</div></div><!-- fragment --><p> After solving the linear system we need to make sure that the constraint values are written into the newton-update. This is done by calling the function <a class="el" href="">AffineConstraints.distribute()</a>. </p><div class="fragment"><div class="line">    <span class="comment">//Write the constraint values into the solution vector (newton-increment) to ensure</span></div><div class="line">    <span class="comment">// that these values are used in the sequent</span></div><div class="line">    constraints.distribute(newton_update);</div><div class="line">    <span class="comment">//Return the number of iterations of the iterative solver and the residual</span></div><div class="line">    <span class="keywordflow">return</span> std::make_pair(lin_it, lin_res);</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="sebsec6"></a>
MISC</h2>
<p>The last section briefly discusses the remaining member functions of the solver class with the exception of make_grid and system_setup, which has been to focus of previous exercises. Furthermore, we will not discuss the <a class="el" href="classSolid.html#ae96bd2d3c54d563be2807dad0a69eae6">Solid&lt;dim&gt;::output_results</a> functions since it is the topic of the next exercises. The first functions are solely used to print some information (in a formatted manner) to the screen and self-explanatory.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="classSolid.html#a455fd203c4b9d51adc6f3d342438e619">Solid&lt;dim&gt;::print_conv_header</a>()</div><div class="line">{</div><div class="line">    <span class="keywordtype">double</span> step_fraction = double(current_load_step)/double(load_steps);</div><div class="line">    <span class="keywordtype">double</span> current_load = load_magnitude * step_fraction;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;\nStep &quot;</span> &lt;&lt; current_load_step &lt;&lt; <span class="stringliteral">&quot; out of &quot;</span></div><div class="line">            &lt;&lt; load_steps &lt;&lt; <span class="stringliteral">&quot; load steps with current load: &quot;</span>&lt;&lt;step_fraction&lt;&lt;<span class="stringliteral">&quot;*&quot;</span></div><div class="line">            &lt;&lt;load_magnitude&lt;&lt;<span class="stringliteral">&quot; = &quot;</span>&lt;&lt;current_load &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> l_width = 90;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; l_width; ++i)</div><div class="line">    {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;_&quot;</span>;</div><div class="line">    }</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;           SOLVER STEP            &quot;</span></div><div class="line">                &lt;&lt; <span class="stringliteral">&quot; |  LIN_IT   LIN_RES    RES_NORM    &quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; l_width; ++i)</div><div class="line">    {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;_&quot;</span>;</div><div class="line">    }</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="classSolid.html#ab48809d37645524e0e227df318ac2cf5">Solid&lt;dim&gt;::print_conv_footer</a>()</div><div class="line">{</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> l_width = 90;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; l_width; ++i)</div><div class="line">    {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;_&quot;</span>;</div><div class="line">    }</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Errors:&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Rhs: \t\t&quot;</span> &lt;&lt; error_residual.u &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p> The next function computes the l2-norm of the residual, excluding constraint degrees of freedom since, depending on the chosen method to impose constraints, may not be zero and would lead the impression of a non-converging problem. </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="classSolid.html#a2d8ba8b46344071ab24526312cc75757">Solid&lt;dim&gt;::get_error_residual</a>(Errors &amp;error_residual)</div><div class="line">{</div><div class="line">    <span class="comment">//This step is necessary if the entry of the vector</span></div><div class="line">    <span class="comment">// at a constrained dof is not zero - this depends on </span></div><div class="line">    <span class="comment">// the way constraints are imposed; To be sure it is </span></div><div class="line">    <span class="comment">//safer to only consider the unconstrained entries anyway</span></div><div class="line">    Vector&lt;double&gt; error_res(dof_handler_ref.n_dofs());</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dof_handler_ref.n_dofs(); ++i)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">if</span> (!constraints.is_constrained(i))</div><div class="line">        {</div><div class="line">            error_res(i) = system_rhs(i);</div><div class="line">        }</div><div class="line">    }</div><div class="line">    error_residual.u = error_res.l2_norm();</div><div class="line">}</div></div><!-- fragment --><p>The following function is used during the assembly process to get the current total solution including the current newton-increments, which are added to solution_delta in the NR-algorithm <a class="el" href="classSolid.html#a2ca1326fa3a3c4f6395ef22b80923f45">Solid&lt;dim&gt;::solve_load_step_NR</a>.</p>
<div class="fragment"><div class="line"> <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">Vector&lt;double&gt;</div><div class="line"><a class="code" href="classSolid.html#a36d2e8393638add571681728b91934ef">Solid&lt;dim&gt;::get_total_solution</a>(<span class="keyword">const</span> Vector&lt;double&gt; &amp;solution_delta)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">    <span class="comment">//solution_n = converged solution from last load step n</span></div><div class="line">    Vector&lt;double&gt; solution_total(solution_n);</div><div class="line">    solution_total += solution_delta;</div><div class="line">    <span class="keywordflow">return</span> solution_total;</div><div class="line">}</div></div><!-- fragment --><p>Once you completed all task you can run the program and look at the results in paraview. Feel free to manipulate certain parameters and check the impact on the results. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jan 25 2021 10:06:03 for Coding Assignment 4 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
