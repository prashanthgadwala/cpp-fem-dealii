<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Coding Assignment 3: Coding Assignment 3</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Coding Assignment 3
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Coding Assignment 3 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#sec">Introduction</a></li>
<li class="level1"><a href="#sec1">make_grid()</a></li>
<li class="level1"><a href="#sec2">system_setup()</a></li>
<li class="level1"><a href="#sec3">Renumbering algorithms</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="sec"></a>
Introduction</h1>
<p>In this coding assignment another step towards the actual finite element implementation is done. Every FE program needs a mesh to work on and a way to handle degrees of freedoms associated to a mesh and a given Finite Element space. In <em>deal.II</em> this is achieved using Triangulation&lt;dim&gt; and DoFHandler&lt;dim&gt; (NOTE: there are also extensions of these classes as discussed in the exercise). In this assignement you will write functions to create a mesh and assigning so-called boundary indicators and distribute degrees of freedom based on a Finite Element space for an elasticity problem. Before we start lets quickly discuss the basic structure of the FE-solver that we will develop in this course.</p>
<p>As always make use of the deal.II online library <a href="https://dealii.org/9.1.1/doxygen/deal.II/">deal.II</a></p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span><a class="code" href="classSolid.html">Solid</a></div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <a class="code" href="classSolid.html#ae450e03bcac17b7d04cd4904f2a0653f">Solid</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="classSolid.html#aa1c48b3fb0a5221ee6df0acd067dcb5a">load_steps</a>, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> poly_degree, <span class="keywordtype">double</span> load_magnitude,</div><div class="line">                    <span class="keywordtype">double</span> mu, <span class="keywordtype">double</span> lambda);</div><div class="line">    <a class="code" href="classSolid.html#a8360ff83b082cfa2ff66a677f60e0c3f">~Solid</a>( );</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="classSolid.html#a012c69961c6f1c4d351a243eaa910cbd">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    </div><div class="line">    <span class="comment">//Generate a mesh</span></div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="classSolid.html#a316ca1d5318457163f16e04f121eb88f">make_grid</a>();</div><div class="line">    <span class="comment">//Distribute degrees of freedom and set up specific containers</span></div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="classSolid.html#a967492d94e02b5d52bd1f8c8e3054820">system_setup</a>();</div><div class="line">    <span class="comment">//Assemble the linear system</span></div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="classSolid.html#a6162f2ab87e3061ab2a44280b472af0b">assemble_system</a>();</div><div class="line">    <span class="comment">//Apply haning node and Dirichlet constraints</span></div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="classSolid.html#a264a27250d20aea587d738de48751192">make_constraints</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> &amp;it_nr);</div><div class="line">    <span class="comment">//Newton-Raphson algorithm</span></div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="classSolid.html#a123484110a163732e816396189cad59c">solve_newton_step</a>(Vector&lt;double&gt; &amp;<a class="code" href="classSolid.html#aae5703fd97fa620fc000ea58a23d1f86">solution_delta</a>);</div><div class="line">    <span class="comment">//Solve a linear system</span></div><div class="line">    std::pair&lt;unsigned int, double&gt; <a class="code" href="classSolid.html#a0077c66f595439e90b0fe5ba9e5b5d9c">solve_linear_system</a>(Vector&lt;double&gt; &amp;newton_update);</div><div class="line"></div><div class="line"></div><div class="line">    Vector&lt;double&gt; <a class="code" href="classSolid.html#a268aa38ff086c2baf23eae1986222a96">get_total_solution</a>(<span class="keyword">const</span> Vector&lt;double&gt; &amp;<a class="code" href="classSolid.html#aae5703fd97fa620fc000ea58a23d1f86">solution_delta</a>) <span class="keyword">const</span>;</div><div class="line">    <span class="comment">//Write the results into a vtu file</span></div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="classSolid.html#ae96bd2d3c54d563be2807dad0a69eae6">output_results</a>() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    Triangulation&lt;dim&gt;               <a class="code" href="classSolid.html#af6e0f538fc872d43191df1be76e07239">triangulation</a>;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>               <a class="code" href="classSolid.html#aa9b943faeae4b8ef4a102c1860b36340">degree</a>;</div><div class="line">    <span class="keyword">const</span> FESystem&lt;dim&gt;              <a class="code" href="classSolid.html#a61b64a6a502953c8e76367c155903080">fe</a>;</div><div class="line">    DoFHandler&lt;dim&gt;                  <a class="code" href="classSolid.html#a65fdeac8b1cc65245162c98e06a26bf7">dof_handler_ref</a>;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>               <a class="code" href="classSolid.html#a7d1e7e61ded76061b7ae22b1fdeb2ceb">dofs_per_cell</a>;</div><div class="line">    <span class="keyword">const</span> FEValuesExtractors::Vector <a class="code" href="classSolid.html#a4de5ae991dbf3dcb928d0e40b9eae6dd">u_fe</a>;</div><div class="line">    </div><div class="line">    <span class="keyword">enum</span></div><div class="line">    {</div><div class="line">        <a class="code" href="classSolid.html#a4dff9d552ab8d50906c5d360a5ac0bafa86af8aff12592f1184087ee02df9f6b8">u_dof</a> = 0</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">const</span> QGauss&lt;dim&gt;                <a class="code" href="classSolid.html#adcd7596f6521749c8a4c7ffda312df8c">qf_cell</a>;</div><div class="line">    <span class="keyword">const</span> QGauss&lt;dim - 1&gt;            <a class="code" href="classSolid.html#af7bc06632b5398d401231271fc6210d4">qf_face</a>;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>               <a class="code" href="classSolid.html#ae5a57e65024a6a944d6b7fdbefe7d758">n_q_points</a>;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>               <a class="code" href="classSolid.html#a7b53ed7a72e5d54c84f503d6a0723a11">n_q_points_f</a>;</div><div class="line"></div><div class="line">    AffineConstraints&lt;double&gt;                 <a class="code" href="classSolid.html#acc382693b221fb1d605263459d13cb67">constraints</a>;</div><div class="line"></div><div class="line">    SparsityPattern             <a class="code" href="classSolid.html#a12bede2d628b64a711fe3d9d539c1e0d">sparsity_pattern</a>;</div><div class="line">    SparseMatrix&lt;double&gt;        <a class="code" href="classSolid.html#a715e352228e11a902d20b15bae00aa85">tangent_matrix</a>;</div><div class="line">    Vector&lt;double&gt;              <a class="code" href="classSolid.html#ae9e56668508a30b302ccaf349dbad715">system_rhs</a>;</div><div class="line">    Vector&lt;double&gt;              <a class="code" href="classSolid.html#a53db1508424f4fbed840574d9b8932e0">solution_n</a>;</div><div class="line">    Vector&lt;double&gt;              <a class="code" href="classSolid.html#aae5703fd97fa620fc000ea58a23d1f86">solution_delta</a>;</div><div class="line"></div><div class="line">    ...</div><div class="line">    <span class="comment">//-------------------------------------------------------------------------     </span></div><div class="line">};</div></div><!-- fragment --><p>In essence every FE-solver requires to have a mesh, a definition of a Finite Element space, assemble a linear system, some containers to store a linear system, an algorithm to solve the linear system and some way to visualize the results. In the first part we will work on algorithms to generate a mesh (function inside a namespace). We will then use in the second part a Finite Element space as discussed in the exercise via FESystem&lt;dim&gt;. Afterwards the degrees of freedom will be distributed and several numbering schemes will be compared in terms of their band structure. Eventually we will look at an option of the function that we use to generate a sparsity pattern (<a class="el" href="">DoFTools::make_sparsity_pattern</a>).</p>
<p>As usual look out for the following</p>
<p><em>BEGIN</em> ENTER CODE HERE</p>
<p><em>END</em> ENTER CODE HERE</p>
<p>which indicates where you should complete the code.</p>
<p>As always make use of the deal.II online library <a href="https://dealii.org/9.1.1/doxygen/deal.II/">deal.II</a></p>
<p>Also, recall to first load the environment variable in a shell via</p>
<p><em>spack</em> load dealii</p>
<p>and then execute cmake</p>
<p><em>cmake</em> .</p>
<p>in the current folder to generate the Makefile. You can then use "make debug" or "make release" to switch between the two configurations and finally "make run" to execute the program.</p>
<h1><a class="anchor" id="sec1"></a>
make_grid()</h1>
<p>In this part we will have a look at the namespace <a class="el" href="namespaceHyperCubeWithRefinedHole.html">HyperCubeWithRefinedHole</a> (inside <a class="el" href="HyperCubeWithRefinedHole_8h.html">HyperCubeWithRefinedHole.h</a>). Within this namespace we have three functions: <a class="el" href="namespaceHyperCubeWithRefinedHole.html#a1fbbc00d062f1a09cf10fba0405708a9">HyperCubeWithRefinedHole::set_and_execute_refinements</a>, <a class="el" href="namespaceHyperCubeWithRefinedHole.html#a3d0723c51a084ef57a619e93953bfcb0">HyperCubeWithRefinedHole::set_boundary_ids</a> and <a class="el" href="namespaceHyperCubeWithRefinedHole.html#a355bcebf8c1667963389fdba8a712e9a">HyperCubeWithRefinedHole::generate_grid</a>. You will on the first two functions while the latter is already setup for you:</p>
<div class="fragment"><div class="line"><span class="comment">//This function uses the GridGenerator to generate a</span></div><div class="line"><span class="comment">//hypercupe with cylindrical hole</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceHyperCubeWithRefinedHole.html#a355bcebf8c1667963389fdba8a712e9a">generate_grid</a>(Triangulation&lt;dim&gt; &amp;triangulation,</div><div class="line">                            <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> int_nbr_refinements,</div><div class="line">                            <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> id_dirichelt_boundary,</div><div class="line">                          <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> id_neumann_boundary )</div><div class="line">{</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> outer_radius = 1.0;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> inner_radius = 0.5;</div><div class="line">    <span class="keyword">const</span> Point&lt;dim&gt; center;</div><div class="line">    <span class="comment">//Make use of dealii function from namespace GridGenerator</span></div><div class="line">    GridGenerator::hyper_cube_with_cylindrical_hole(triangulation,</div><div class="line">                                                    inner_radius,</div><div class="line">                                                 outer_radius,</div><div class="line">                                                 0.5,</div><div class="line">                                                 1,</div><div class="line">                                                 <span class="keyword">false</span> );<span class="comment">//boundary_id_inner_hole is set to 1</span></div><div class="line">    <span class="comment">//Use a unique_ptr (recall smart pointers) to choose on-the-fly between</span></div><div class="line">    <span class="comment">//spherical manifold description (2D) or cylindrical (3D)</span></div><div class="line">    std::unique_ptr&lt;Manifold&lt;dim&gt;&gt; ptr_manifold=<span class="keyword">nullptr</span>;</div><div class="line">    </div><div class="line">    <span class="keywordflow">if</span>(dim==2)</div><div class="line">    {</div><div class="line">        ptr_manifold = std::make_unique&lt;SphericalManifold&lt;dim&gt;&gt;(center);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dim==3)</div><div class="line">    {</div><div class="line">        ptr_manifold = std::make_unique&lt;CylindricalManifold&lt;dim&gt;&gt;(dim-1);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;only allowed for dim == 2 or dim == 3&quot;</span>);</div><div class="line">    }</div><div class="line">    </div><div class="line">    types::boundary_id boundary_id_inner_hole=1;</div><div class="line">    types::manifold_id manifold_id_inner_hole=1;</div><div class="line">    <span class="comment">//Set the manifold id of all boundary faces and edges with given boundary id </span></div><div class="line">    triangulation.set_all_manifold_ids_on_boundary(boundary_id_inner_hole,manifold_id_inner_hole);</div><div class="line">    <span class="comment">//If this is not done and the manifold_id equals number::invalid_manifold_id (which is default)</span></div><div class="line">    <span class="comment">//the triangulation object queries the boundary_id if the face is at the boundary or the material_id</span></div><div class="line">    </div><div class="line">    triangulation.set_manifold (manifold_id_inner_hole, *ptr_manifold);</div><div class="line">    </div><div class="line">    triangulation.refine_global(1);</div><div class="line">    <a class="code" href="namespaceHyperCubeWithRefinedHole.html#a1fbbc00d062f1a09cf10fba0405708a9">set_and_execute_refinements</a>(int_nbr_refinements, triangulation, boundary_id_inner_hole);</div><div class="line">    triangulation.reset_manifold(manifold_id_inner_hole);</div><div class="line">        </div><div class="line">    <a class="code" href="namespaceHyperCubeWithRefinedHole.html#a3d0723c51a084ef57a619e93953bfcb0">set_boundary_ids</a>(triangulation,id_dirichelt_boundary, id_neumann_boundary, outer_radius);</div><div class="line">}</div></div><!-- fragment --><p>Your task is to complete the first two functions at the indicated positions. The first function takes care about the refinement towards the inner hole of our geometry and is called from <a class="el" href="namespaceHyperCubeWithRefinedHole.html#a355bcebf8c1667963389fdba8a712e9a">HyperCubeWithRefinedHole::generate_grid</a>. We loop over all cells, followed by a loop over all faces (note how we query the number of faces depending on dim). What we want to achive is, that in case that a face is at the inner hole, it should be flaged for refinement using cell-&gt;set_refine_flag();. You can query a face using cell-&gt;face(j) for the j-th face and also ask if it is on the boundary (-&gt;at_boundary()) and for its boundary id (-&gt;boundary_id()).</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceHyperCubeWithRefinedHole.html#a1fbbc00d062f1a09cf10fba0405708a9">set_and_execute_refinements</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> number_refinements, Triangulation&lt;dim&gt; &amp;triangulation, types::boundary_id boundary_id_inner_hole)</div><div class="line">{</div><div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;number_refinements; i++)</div><div class="line">    {</div><div class="line">        <span class="keyword">typename</span> Triangulation&lt;dim&gt;::active_cell_iterator cell= triangulation.begin_active(),</div><div class="line">                                                endc = triangulation.end();</div><div class="line">        <span class="keywordflow">for</span>(; cell!=endc; ++cell)</div><div class="line">        {</div><div class="line">            <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;GeometryInfo&lt;dim&gt;::faces_per_cell; j++)</div><div class="line">            {</div><div class="line">                BEGIN ENTER CODE HERE</div><div class="line"></div><div class="line">                END ENTER CODE HERE</div><div class="line">            }</div><div class="line">        }</div><div class="line">        triangulation.execute_coarsening_and_refinement();      </div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Next, we want to assing distinct boundary id's to for the inhomogeneous Neumann and the general Dirichlet parts of the boundary. This is done in <a class="el" href="namespaceHyperCubeWithRefinedHole.html#a3d0723c51a084ef57a619e93953bfcb0">HyperCubeWithRefinedHole::set_boundary_ids</a> also called from <a class="el" href="namespaceHyperCubeWithRefinedHole.html#a355bcebf8c1667963389fdba8a712e9a">HyperCubeWithRefinedHole::generate_grid</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceHyperCubeWithRefinedHole.html#a3d0723c51a084ef57a619e93953bfcb0">set_boundary_ids</a>(Triangulation&lt;dim&gt; &amp;triangulation, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> id_Dirichlet, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> id_Neumann, <span class="keywordtype">double</span> outer_radius)</div><div class="line">{</div><div class="line">    <span class="keyword">typename</span> Triangulation&lt;dim&gt;::active_cell_iterator cell= triangulation.begin_active(),</div><div class="line">                                            endc = triangulation.end();</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span>(; cell!=endc; ++cell)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;GeometryInfo&lt;dim&gt;::faces_per_cell; j++)</div><div class="line">        {</div><div class="line">            BEGIN ENTER CODE HERE</div><div class="line"></div><div class="line">            END ENTER CODE HERE</div><div class="line">        }</div><div class="line">        </div><div class="line">    }   </div><div class="line">}</div></div><!-- fragment --><p>We again loop over all cells and faces and now need to check for the respective parts of the boundary. The boundary id of a face can be set using -&gt;set_boundary_id(id). The values for the respective parts are being past as input arguments, i.e. id_Dirichlet and id_Neumann. Hint: use outer_radius and cell-&gt;center(), which returns a point, to find out to which boundary a certain face at the boundary belongs (remember how to compare two double values and assign the Dirichlet boundary for the part of the domain with \( x = (-1 * \text{outer_radius})\) and Neumann boundary for the part with \( x = (1 * \text{outer_radius})\) as indicated in the picture below).</p>
<div class="image">
<img src="mesh_3d_with_boundaries.png" style="width:404px;height:328px;"/>
</div>
<p>You can run the code now. If you wanted to check for boundary id's you could use for instance</p>
<div class="fragment"><div class="line">std::cout&lt;&lt;<span class="stringliteral">&quot;Face at Neumann boundary at:&quot;</span>&lt;&lt;cell-&gt;face(j)-&gt;center()&lt;&lt;std::endl;</div></div><!-- fragment --><p>at the place where you indentify the boundaries and set the id's (i.e. <a class="el" href="namespaceHyperCubeWithRefinedHole.html#a3d0723c51a084ef57a619e93953bfcb0">HyperCubeWithRefinedHole::set_boundary_ids</a>) and should get the output:</p>
<div class="fragment"><div class="line">Face at Neumann boundary at:1 0.25</div><div class="line">Face at Neumann boundary at:1 0.75</div><div class="line">Face at Dirichlet boundary at:-1 0.75</div><div class="line">Face at Dirichlet boundary at:-1 0.25</div><div class="line">Face at Dirichlet boundary at:-1 -0.25</div><div class="line">Face at Dirichlet boundary at:-1 -0.75</div><div class="line">Face at Neumann boundary at:1 -0.75</div><div class="line">Face at Neumann boundary at:1 -0.25</div></div><!-- fragment --><p>You can also use paraview to open the mesh HyperCubeWithRefinedHole.inp.</p>
<h1><a class="anchor" id="sec2"></a>
system_setup()</h1>
<p>The solver is switched on by calling from <a class="el" href="CA__3_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a> the function <a class="el" href="classSolid.html#a012c69961c6f1c4d351a243eaa910cbd">Solid&lt;dim&gt;::run()</a>.</p>
<div class="fragment"><div class="line"> <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="classSolid.html#a012c69961c6f1c4d351a243eaa910cbd">Solid&lt;dim&gt;::run</a>()</div><div class="line">{</div><div class="line">    make_grid();</div><div class="line">    system_setup();</div><div class="line">    <span class="comment">//-----------more to come</span></div><div class="line">}</div></div><!-- fragment --><p>As of now, this function solely calls two additional functions, i.e. <a class="el" href="classSolid.html#a316ca1d5318457163f16e04f121eb88f">Solid&lt;dim&gt;::make_grid()</a> and <a class="el" href="classSolid.html#a967492d94e02b5d52bd1f8c8e3054820">Solid&lt;dim&gt;::system_setup()</a>. The definition of the Finite Element space in accordance with the exercise has been carried out in the constructor of the solver class:</p>
<div class="fragment"><div class="line"> <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classSolid.html#ae450e03bcac17b7d04cd4904f2a0653f">Solid&lt;dim&gt;::Solid</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> load_steps, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> poly_degree, <span class="keywordtype">double</span> load_magnitude,</div><div class="line">                <span class="keywordtype">double</span> mu, <span class="keywordtype">double</span> lambda)</div><div class="line">:</div><div class="line">degree(poly_degree),</div><div class="line">fe(FE_Q&lt;dim&gt;(degree), dim), <span class="comment">// dim copies of FE_Q&lt;dim&gt; of degree &quot;degree&quot; - Definition of the FE space</span></div><div class="line">dof_handler_ref(triangulation),<span class="comment">//attach the triangulation to the dofhandler</span></div><div class="line">dofs_per_cell (fe.dofs_per_cell),</div><div class="line">u_fe(0),</div><div class="line">qf_cell(2),</div><div class="line">qf_face(2),</div><div class="line">n_q_points (qf_cell.size()),</div><div class="line">n_q_points_f (qf_face.size()),</div><div class="line">mu(mu),</div><div class="line">lambda(lambda),</div><div class="line">load_magnitude(load_magnitude),</div><div class="line">load_steps(load_steps)</div><div class="line">{</div><div class="line">}</div></div><!-- fragment --><p>The function <a class="el" href="classSolid.html#a316ca1d5318457163f16e04f121eb88f">Solid&lt;dim&gt;::make_grid()</a> simply generates a mesh as discussed in the last part:</p>
<div class="fragment"><div class="line"> <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="classSolid.html#a316ca1d5318457163f16e04f121eb88f">Solid&lt;dim&gt;::make_grid</a>()</div><div class="line">{</div><div class="line">    HyperCubeWithRefinedHole::generate_grid&lt;dim&gt;(triangulation,</div><div class="line">                                                 nbr_adaptive_refinements,</div><div class="line">                                                id_Dirichlet_boundary,</div><div class="line">                                                id_Neumann_boundary);     </div><div class="line">    </div><div class="line">    std::ofstream out_ucd(<span class="stringliteral">&quot;Grid_HyperCubeWithRefinedHole.inp&quot;</span>);</div><div class="line">    GridOut grid_out;</div><div class="line">    GridOutFlags::Ucd ucd_flags(<span class="keyword">true</span>,<span class="keyword">true</span>,<span class="keyword">true</span>);</div><div class="line">    grid_out.set_flags(ucd_flags);</div><div class="line">    grid_out.write_ucd(triangulation, out_ucd);</div><div class="line">    std::cout&lt;&lt;<span class="stringliteral">&quot;Mesh written to Grid_HyperCubeWithRefinedHole.inp &quot;</span>&lt;&lt;std::endl;</div><div class="line">}</div></div><!-- fragment --><p>The second function is the second part of todays exercise.</p>
<div class="fragment"><div class="line"> <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="classSolid.html#a967492d94e02b5d52bd1f8c8e3054820">Solid&lt;dim&gt;::system_setup</a>()</div><div class="line">{</div></div><!-- fragment --><p>First we have to distribute degrees of freedom using the function <a class="el" href="">DoFHandler&lt;dim&gt;::distribute_dofs</a>. Keep in mind the we named our instance for the Finite Element space <a class="el" href="classSolid.html#a61b64a6a502953c8e76367c155903080">Solid&lt;dim&gt;::fe</a> and the DoFHandler <a class="el" href="classSolid.html#a65fdeac8b1cc65245162c98e06a26bf7">Solid&lt;dim&gt;::dof_handler_ref</a>. This is already done for you.</p>
<div class="fragment"><div class="line"><span class="comment">//BEGIN - INSERT YOUR CODE HERE</span></div><div class="line">dof_handler_ref.distribute_dofs(fe);</div><div class="line"><span class="comment">//Distribute degrees of freedom using the definition of the finite element space - &quot;fe&quot;</span></div><div class="line"><span class="comment">//Check the documentation of the DoFHandler class and look for a function</span></div><div class="line"><span class="comment">//&quot;distribute_dofs&quot;.</span></div></div><!-- fragment --><p>Afterwards we want to apply a renumbering of the degrees of freedom in order to increase performance. We will see later on the effects of different renumbering schemes. For know use <a class="el" href="">DoFRenumbering::Cuthill_McKee</a>.</p>
<div class="fragment"><div class="line"><span class="comment">//Apply a renumbering scheme</span></div></div><!-- fragment --><p> Next, we setup the AffineConstraints to take care of hanging nodes. The concept of hanging nodes and the way the are constraint in deal.ii has been discussed in the last exercise. The AffineConstraints will also be used in the next exercise to incorporate Dirichlet type constraints. </p><div class="fragment"><div class="line"><span class="comment">//Before we set the constraints the instance has to be cleared. This step is already implemented for you.</span></div><div class="line">constraints.clear();</div><div class="line">DoFTools::make_hanging_node_constraints (dof_handler_ref,constraints);</div><div class="line">constraints.close();</div><div class="line"></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Triangulation:&quot;</span></div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;\n\t Number of active cells: &quot;</span> &lt;&lt; triangulation.n_active_cells()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;\n\t Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler_ref.n_dofs()</div><div class="line">            &lt;&lt; std::endl;</div></div><!-- fragment --><p>The next step consists of creating a sparsity pattern as discussed in the exercise. Due to some performance considerations and the internal data structure an intermediate quantity is utilized (DynamicSparsityPattern). This step is already implemented for you. After the sparsity pattern is generated use it to reinitialize the sparse matrix and further allocate memory for the instances of Vector&lt;double&gt;, i.e. the <a class="el" href="classSolid.html#a53db1508424f4fbed840574d9b8932e0">Solid&lt;dim&gt;::solution_n</a> and the remaining quantities.</p>
<div class="fragment"><div class="line">    tangent_matrix.clear();</div><div class="line">    <span class="keyword">const</span> types::global_dof_index n_dofs_u = dof_handler_ref.n_dofs();</div><div class="line"></div><div class="line"></div><div class="line">    DynamicSparsityPattern dsp(n_dofs_u, n_dofs_u);</div><div class="line">    DoFTools::make_sparsity_pattern(dof_handler_ref,</div><div class="line">                                dsp,</div><div class="line">                                constraints,</div><div class="line">                                <span class="keyword">true</span>);</div><div class="line">    sparsity_pattern.copy_from (dsp);</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> number_entries = sparsity_pattern.n_nonzero_elements();</div><div class="line">    std::cout&lt;&lt;<span class="stringliteral">&quot;Size of sparsity-pattern: &quot;</span>&lt;&lt;number_entries&lt;&lt;std::endl;</div><div class="line">    std::ofstream out (<span class="stringliteral">&quot;sparsity_pattern1.svg&quot;</span>);</div><div class="line">    sparsity_pattern.print_svg (out);   </div><div class="line">    </div><div class="line">    <span class="comment">//Initialize sparse matrix and vector instances. Look out for a function with the name &quot;reinit&quot;.</span></div><div class="line">    </div><div class="line">    <span class="comment">//END - INSERT YOUR CODE HERE</span></div><div class="line"></div><div class="line">}</div></div><!-- fragment --><p>If everything is implemented correctly you will get two output files, i.e. "sparsity_pattern1.svg" and "HyperCubeWithRefinedHole.inp". The latter corresponds to the mesh. The primer can be opened for instance in your web browser and will show the sparsity pattern, according to the chosen number scheme. For the Cuthill_McKee algorithm the result was shown in the exercise.</p>
<div class="image">
<img src="SparsityPattern.png" style="width:404px;height:328px;"/>
</div>
<h1><a class="anchor" id="sec3"></a>
Renumbering algorithms</h1>
<p>After the successful implementation of the member function <a class="el" href="classSolid.html#a967492d94e02b5d52bd1f8c8e3054820">Solid&lt;dim&gt;::system_setup()</a> you should run the program with the DoFRenumbering::Cuthill_McKee renumbering, without any renumbering, i.e. the default distribution, and using DoFRenumbering::random. Considering the respective patterns what is your conclusion? Furthermore, look at the function <a class="el" href="">DoFTools::make_sparsity_pattern</a>. The 4th input parameter was set to true. Read through the documentation and change its value. How does this effect the sparsity pattern? </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Jan 19 2021 11:52:08 for Coding Assignment 3 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
